<!DOCTYPE html>
<meta charset="utf-8">
<style>

.chart div {
  font: 10px sans-serif;
  background-color: steelblue;
  text-align: right;
  padding: 3px;
  margin: 1px;
  color: white;
}

</style>
<svg></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var bigR = 360; // radius of entire plot
var c = 5; // number of emotion categories
var t = 3; // number of intensity levels per category PLUS 1 //TODO is it plus or minus?
var p = 0.75; // proportion of (circle area / next biggest circle area)
var g = 0.01; // gap between category sectors as [(gap size) / (circle size * c)]
var s = 25; // space between same intensity levels (in pixels)
var q = 0.15; // percentage larger (or if negative, smaller) than outside radius that center is
var fSize = 19; // size of font for text labels

var fontFam = "impact"; // CSS standard font family choice for text labels
var fontSize = 24; // default font size for text labels
var preciR = 0.05; // precision (radius): increments of percentage to decrease radius while checking overlap
var preciS = 0.05; // precision (spacing): increments of percentage to decrease space while checking over-spacing
var spacePad = 0.1; // when checking over-spacing, allowable percentage/amount of extra space (i.e., s * spacePad)
var expFactor = 1.2; // exponential scaling factor, where each r = 2 * r * p^(l*expFactor)

// array [of arrays of size 2] of size c, such that index 0=category name and 1=category color
// ex. [[name0, color0], [name1, color1], [name2, color2]]
var catInfo = [
	//["sweet","orchid"],["sour","mediumspringgreen"],["salty","lightslategray"],["bitter","maroon"],["umami","goldenrod"]
	["sweet", "orchid"],
	["sour", "mediumspringgreen"],
	["salty", "lightslategray"],
	["bitter", "goldenrod"],
	["umami", "maroon"]
];

var summa1 = 0;
for (i = 0; i < t+1; i++)
{
	summa1 += 2 * Math.pow(p, i);
}
var r = ((bigR - (s*t) - s) / (summa1 + (1+q)));

function distance(x1, y1, x2, y2)
// finds distance between points (x1, y1) and (x2, y2)
{
	var underRadical = Math.pow((x2-x1), 2) + Math.pow((y2-y1), 2);
	return Math.pow(underRadical, 0.5);
}
function checkOverlap(dist, layer, inc)
{
	var origRad = r * Math.pow(p, layer*expFactor);
	var multiplier = 1 - (inc * preciR);

	var layerCircum = 0;
	if (layer == 0)
	{
		layerCircum = 2 * Math.PI * (bigR - r);
	}
	else
	{
		layerCircum = 2 * Math.PI * (bigR - summa2(layer) - r);
	}
	var gap = g * layerCircum;
	var needSpace = (2 * origRad * multiplier) + gap;

	if (dist >= needSpace)
	{
		return true;
	}
	else
	{
		return false;
	}
}
function checkSpacing(dist, layer, inc)
{
	var outerRad = r * Math.pow(r, layer);
	var innerRad = r * Math.pow(r, layer+1);
	var maxSpace = outerRad + (s * (1+spacePad)) + innerRad;

	var distScale = dist * (1 - (inc*preciS));

	if (distScale <= maxSpace)
	{
		return true;
	}
	else
	{
		return false;
	}
}

function summa2(l)
// finds summation, from i = 0 to i = l, of 2*r*p^i; plus s * (l-1); plus p^(l-1)
{
	var result = 0;
	for (var k = 0; k < l+1; k++)
	{
		var term = 2 * r * Math.pow(p, k);
		result += term;
	}
	result += s * (l-1);
	result += Math.pow(p, l-1);
	return result;
}

// initialize list with manually set scale variables
var manSclRad = [];
var manSclSpc = [];

// test distances to check over-spacing
for (var i = 0; i < t+1; i++)
{
	var outRad = r * Math.pow(p, i*expFactor);
	var inRad = r * Math.pow(p, (i+1)*expFactor);
	var outZ = summa2(i) + r;
		if (i == 0) { outZ = r + s; } //TODO "plus s"?
	var inZ = summa2(i+1) + r;
	
	var trigVal = (2 * Math.PI) / c;
	outX = (bigR - outZ) * Math.cos(trigVal);
	outY = (bigR - outZ) * Math.sin(trigVal);
	inX = (bigR - inZ) * Math.cos(trigVal);
	inY = (bigR - inZ) * Math.sin(trigVal)

	var increments = 0;
	var condition = true;
	while (condition)
	{
		var eval = checkSpacing(distance(outX, outY, inX, inY), i, increments);
		if (eval)
		{
			condition = false;
		}
		else
		{
			increments++;
		}
	}
	manSclSpc[i] = 1 - (increments * preciS);
}

// test distances to check overlapping
for (var i = 0; i < t+1; i++)
{
	var origRad = r * Math.pow(p, i*expFactor);
	var z = summa2(i) + r;
		if (i == 0) { z = r + s; } //TODO "plus s"?
	var x1 = (bigR - z) * manSclSpc[i];
	var y1 = 0;
	var trigVal = (2 * Math.PI) / c;
	var x2 = (bigR - z) * Math.cos(trigVal) * manSclSpc[i];
	var y2 = (bigR - z) * Math.sin(trigVal) * manSclSpc[i];

	var increments = 0;
	var condition = true;
	while(condition)
	{
		var dist = distance(x1, y1, x2, y2);
		var eval = checkOverlap(distance(x1, y1, x2, y2), i, increments);
		if (eval)
		{
			condition = false;
		}
		else
		{
			increments++;
		}
	}
	manSclRad[i] = 1 - (increments * preciR);
}

var allPoints = []; // list of lists, where each entry is a point such that indexes 0=radius, 1=x pos, 2=y pos, 3=cat, 4=intens
var textPos = []; // array of arrays that stores coordinates for each category name textbook as [x, y]
for (var n = 0; n < c; n++)
{
	var trigVal = ((2 * Math.PI) / c) * n;

	//TODO definitely overhaul this section
	var textX = ((bigR + s) * Math.cos(trigVal) * manSclSpc[0]) + bigR;
	var textY = ((bigR + s) * Math.sin(trigVal) * manSclSpc[0]) + bigR;

	if (textX < 0) {textX = 0; }
	if (textY < 0) {textY = 0; }
	textPos.push([textX, textY]);

	for (var l = 0; l < t+1; l++)
	{
		var radius = r * Math.pow(p, l*expFactor) * manSclRad[l];
		var z = summa2(l) + r;
			if (l == 0) { z = r + s; }
		var x = ((bigR - z) * Math.cos(trigVal) * manSclSpc[l]) + bigR;
		var y = ((bigR - z) * Math.sin(trigVal) * manSclSpc[l]) + bigR;

		allPoints.push([radius, x, y, n, l]);
	}
}

// building JSON object construction string
var jsonText = '{ "entries" : [';
for (var iter = 0; iter < allPoints.length; iter++)
{
	var toAdd = '{ "radius":' + allPoints[iter][0];
	toAdd += ' , "x_pos":' + allPoints[iter][1];
	toAdd += ' , "y_pos":' + allPoints[iter][2];
	toAdd += ' , "cat":' + allPoints[iter][3];
	toAdd += ' , "intens":' + allPoints[iter][4];
	if (iter == allPoints.length - 1)
	{
		toAdd += "} ";
	}
	else
	{
		toAdd += '}, ';
	}
	jsonText += toAdd;
}
jsonText += ']}';

var jsonObj = JSON.parse(jsonText);
var jsonData = jsonObj.entries;

var svgContainer = d3.select("body").append("svg");
	//.attr("width", (bigR * 2) + r + 3*s).attr("height", (bigR * 2) + r + 3*s); //TODO reconsider "artificial" 3s (find real value)

var circles = svgContainer.append("g")
	.selectAll("circle")
	.data(jsonData)
	.enter().append("circle");
var circlesAtt = circles
	.attr("cx", function (d) { return d.x_pos; })
	.attr("cy", function (d) { return d.y_pos; })
	.attr("r", function (d) { return d.radius; })
	.style("fill", function (d) {
		return catInfo[d.cat][1]; })
	.style("stroke", function (d) {
		return catInfo[d.cat][1]; })
	.style("stroke-width", 0)
	.on("mouseover", circleMouseOver)
	.on("mouseout", circleMouseOut)
	.on("click", circleMouseClick);
		
var texts = svgContainer.append("g")
	.selectAll("text")
	.data(textPos)
	.enter().append("text");
var textsAtt = texts
	.text(function (d, i) { 
		return catInfo[i][0]; })
	.attr("x", function (d, i) { 
		return d[0];})
	.attr("y", function (d) { return d[1]; })
	.style("fill", "black")
	.style("font-family", fontFam)
	.style("font-size", fSize);

// adjust graph to suit text
var maxTextHeight = 0;
var maxTextWidth = 0;
texts.each(function() 
{
    if (this.getBBox().height > maxTextHeight)
    {
    	maxTextHeight = this.getBBox().height;
    }
    if (this.getBBox().width > maxTextWidth)
    {
    	maxTextWidth = this.getBBox().width;
    }
});

var svgContainerTransform = svgContainer.
	attr("width", (bigR * 2) + r + 3*maxTextWidth).
	attr("height", (bigR * 2) + r + 3*maxTextHeight);

var fourthOfCats = Math.round((c+1)/4);
var textsTransform = texts
	.attr("x", function(d, i) {
		var thisWidth = this.getBBox().width / 2;
		if (i > fourthOfCats && i < c - fourthOfCats)
		{
			var difference = -thisWidth + maxTextWidth/2;
			return d[0] + difference;
		}
		else if (i != fourthOfCats && i != c - fourthOfCats)
		{
			var summed = thisWidth + maxTextWidth/2;
			return d[0] + summed;
		}
		else
		{
			return d[0] + (maxTextWidth*0.75 - thisWidth);
		}
	})
	.attr("y", function(d, i) {
		return d[1] + maxTextHeight;
	});
var circlesTransString = "translate(" + maxTextWidth*0.75 + "," + maxTextHeight + ")";
var circlesTransform = circles
	.attr("cx", function(d, i)
		{
			return d.x_pos + (maxTextWidth*0.75);
		})
	.attr("cy", function(d, i)
		{
			return d.y_pos + maxTextHeight;
		});

// mouse event handlers

var clickFocus = [-1, -1];

function circleMouseOver(d, i)
{
	var thisCat = d.cat;
	var thisColor = catInfo[d.cat][1];
	var thisColorParse = d3.color(thisColor).rgb();
	var changed = toHSL(thisColorParse, 1.75, 0.25);
	
	var allThisCat = d3.selectAll("circle").filter(function(d)
		{
			return d.cat == thisCat;
		});

	allThisCat
		.transition()
		.duration("200")
		.style("fill", changed)
		.style("stroke", changed);

	d3.select(this).attr("r", function(d) { return d.radius * 1.2; });

}
function circleMouseOut(d, i)
{
	var thisCat = d.cat;
	d3.selectAll("circle").filter(function(d)
		{
			return d.cat == thisCat;
		})
		.transition()
		.duration("200")
		.attr("r", function(d)
		{
			return d.radius;
		})
		.style("fill", function (d) {
			return catInfo[d.cat][1]; });
}
function circleMouseClick(d, i)
{
	var clicked = d3.select(this);
	if (clickFocus[0] != -1 && clickFocus[1] != -1) // current selection exists
	{

		var currSelect = d3.selectAll("circle")
			.filter(function(d)
				{
					return d.cat == clickFocus[0];
				})
			.filter(function(d)
				{
					return d.intens == clickFocus[1];
				});
		// visually "undo" selection
		currSelect
			.style("fill-opacity", 1.0)
			.style("stroke-width", 0);
	}

	clicked.each(function(d)
	{
		// if this is the currently selected thing
		if (d.cat == clickFocus[0] && d.intens == clickFocus[1])
		{
			//visually "undo" selection
			clicked
				.style("fill-opacity", 1.0)
				.style("stroke-width", 0);
			//reset clickFocus
			clickFocus[0] = -1;
			clickFocus[1] = -1;
		}

		else
		{
			//visually indicate selection
			clicked
				.style("fill-opacity", 0.0)
				.style("stroke-width", function(d)
					{
						return d.radius * 0.25;
					});	
			//update clickFocus
			clickFocus = [d.cat, d.intens];
		}
	});
}

function toHSL(rgbColor, satProp, briProp)
{
	// takes in a D3 rgb color object, with fields r, g, b
	// takes in percentage darker/lighter compared to original saturation new color should be
	// takes in percentage of original brightness new color should be 
	var r = rgbColor.r;
	var g = rgbColor.g;
	var b = rgbColor.b;
	r /= 255.0;
	g /= 255.0;
	b /= 255.0;
	
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	
	var l = (min + max) / 2;
	
	var s = 0.0;
	if (l <= 0.5)
	{
		s = (max - min) / (max + min);
	}
	else
	{
		s = (max - min) / (2.0 - max - min);
	}

	var h = 0;
	if (max == r)
	{
		h = ((g-b) / (max-min)) * 60;
	}
	else if (max == g)
	{
		h = (2.0 + (b-r)/(max-min)) * 60;
	}
	else // max == b
	{
		h = (4.0 + (r-g)/(max-min)) * 60;
	}
	
	if (h < 0) { h += 360; }
	
	s *= satProp;
	if (s < 0) { s = 0; }
	else if (s > 1) {s = 1; }
	
	if (l <= 0.5) // change for darker colors
		{ l *= (1 + briProp); }
	else // change for lighter colors
		{ l *= (1 - briProp); }

	if (l < 0) { l = 0; }
	else if (l > 1) { l = 1; }
	
	return d3.hsl(h, s, l);
}

</script>